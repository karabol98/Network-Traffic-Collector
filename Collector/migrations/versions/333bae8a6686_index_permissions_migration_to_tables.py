"""Index Permissions migration to tables

Revision ID: 333bae8a6686
Revises: ef8b5745ee3d
Create Date: 2025-04-07 15:18:19.685912

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import sqlite

# revision identifiers, used by Alembic.
revision: str = '333bae8a6686'
down_revision: Union[str, None] = 'ef8b5745ee3d'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('role_permissions',
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.Column('index_name', sa.String(), nullable=False),
    sa.Column('read_permission', sa.Boolean(), nullable=True),
    sa.Column('write_permission', sa.Boolean(), nullable=True),
    sa.Column('delete_permission', sa.Boolean(), nullable=True),
    sa.Column('effective_date', sa.DateTime(), nullable=False),
    sa.Column('expiration_date', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.PrimaryKeyConstraint('role_id', 'index_name'),
    if_not_exists=True
    )
    op.create_table('user_permissions',
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('index_name', sa.String(), nullable=False),
    sa.Column('read_permission', sa.Boolean(), nullable=True),
    sa.Column('write_permission', sa.Boolean(), nullable=True),
    sa.Column('delete_permission', sa.Boolean(), nullable=True),
    sa.Column('effective_date', sa.DateTime(), nullable=False),
    sa.Column('expiration_date', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('user_id', 'index_name'),
    if_not_exists=True
    )
    try:
        op.add_column('roles', sa.Column('description', sa.Text(), nullable=True))
    except sa.exc.OperationalError:
        pass
    try:
        op.add_column('roles', sa.Column('parent_id', sa.Integer(), nullable=True))
    except sa.exc.OperationalError:
        pass
    op.drop_table("_alembic_tmp_roles", if_exists=True)
    with op.batch_alter_table('roles') as batch_op:
        batch_op.alter_column('name', existing_type=sa.VARCHAR(), nullable=False)
        batch_op.create_foreign_key('roles_parent_fk', 'roles', ['parent_id'], ['id'])
    # Migrate existing permissions from roles.allowed_indexes to role_permissions table
    conn = op.get_bind()
    roles = conn.execute(sa.text("SELECT id, allowed_indexes FROM roles WHERE allowed_indexes IS NOT NULL")).fetchall()
    now = sa.func.current_timestamp()

    for role_id, allowed_indexes in roles:
        if allowed_indexes:
            try:
                indexes = allowed_indexes if isinstance(allowed_indexes, dict) else {}
                for index_name, permissions in indexes.items():
                    # Extract permissions - default to False if not specified
                    read = bool(permissions.get('read', False)) if isinstance(permissions, dict) else False
                    write = bool(permissions.get('write', False)) if isinstance(permissions, dict) else False
                    delete = bool(permissions.get('delete', False)) if isinstance(permissions, dict) else False
                    
                    # Insert permission into the new table
                    conn.execute(
                        sa.text(
                            "INSERT INTO role_permissions (role_id, index_name, read_permission, write_permission, delete_permission, effective_date) "
                            "VALUES (:role_id, :index_name, :read, :write, :delete, :effective_date)"
                        ),
                        {
                            "role_id": role_id,
                            "index_name": index_name,
                            "read": read,
                            "write": write,
                            "delete": delete,
                            "effective_date": now
                        }
                    )
            except Exception as e:
                print(f"Error migrating permissions for role {role_id}: {str(e)}")
    # Drop the old allowed_indexes column from roles
    op.drop_column('roles', 'allowed_indexes')
    with op.batch_alter_table('user_roles') as batch_op:
        batch_op.create_foreign_key('user_roles_user_id_fk', 'users', ['user_id'], ['id'])
        batch_op.create_foreign_key('user_roles_role_id_fk', 'roles', ['role_id'], ['id']) 
    # Migrate existing permissions from users.allowed_indexes to user_permissions table
    users = conn.execute(sa.text("SELECT id, allowed_indexes FROM users WHERE allowed_indexes IS NOT NULL")).fetchall()
    now = sa.func.current_timestamp()

    for user_id, allowed_indexes in users:
        if allowed_indexes:
            try:
                indexes = allowed_indexes if isinstance(allowed_indexes, dict) else {}
                for index_name, permissions in indexes.items():
                    # Extract permissions - default to False if not specified
                    read = bool(permissions.get('read', False)) if isinstance(permissions, dict) else False
                    write = bool(permissions.get('write', False)) if isinstance(permissions, dict) else False
                    delete = bool(permissions.get('delete', False)) if isinstance(permissions, dict) else False
                    
                    # Insert permission into the new table
                    conn.execute(
                        sa.text(
                            "INSERT INTO user_permissions (user_id, index_name, read_permission, write_permission, delete_permission, effective_date) "
                            "VALUES (:user_id, :index_name, :read, :write, :delete, :effective_date)"
                        ),
                        {
                            "user_id": user_id,
                            "index_name": index_name,
                            "read": read,
                            "write": write,
                            "delete": delete,
                            "effective_date": now
                        }
                    )
            except Exception as e:
                print(f"Error migrating permissions for user {user_id}: {str(e)}")
    # Drop the old allowed_indexes column from users
    op.drop_column('users', 'allowed_indexes')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('allowed_indexes', sqlite.JSON(), nullable=True))
    op.add_column('roles', sa.Column('allowed_indexes', sqlite.JSON(), nullable=True))
    op.drop_table("_alembic_tmp_roles", if_exists=True)
    with op.batch_alter_table('roles') as batch_op:
        batch_op.alter_column('name', existing_type=sa.VARCHAR(), nullable=True)
        batch_op.drop_constraint('roles_parent_fk', 'roles', type_='foreignkey')
        batch_op.drop_column('parent_id')
        batch_op.drop_column('description')
    op.drop_index(op.f('ix_roles_role_id'), table_name='roles')
    op.create_index('ix_roles_id', 'roles', ['id'], unique=False)

    # Migrate permissions from role_permissions back to roles.allowed_indexes
    conn = op.get_bind()
    role_permissions = conn.execute(sa.text(
        "SELECT role_id, index_name, read_permission, write_permission, delete_permission FROM role_permissions"
    )).fetchall()
    
    # Group permissions by role_id
    role_permissions_dict = {}
    for role_id, index_name, read, write, delete in role_permissions:
        if role_id not in role_permissions_dict:
            role_permissions_dict[role_id] = {}
        
        role_permissions_dict[role_id][index_name] = {
            'read': bool(read),
            'write': bool(write),
            'delete': bool(delete)
        }
    
    # Update each role with its permissions
    for role_id, permissions in role_permissions_dict.items():
        conn.execute(
            sa.text("UPDATE roles SET allowed_indexes = :permissions WHERE id = :role_id"),
            {"permissions": permissions, "role_id": role_id}
        )
    
    # Migrate permissions from user_permissions back to users.allowed_indexes
    user_permissions = conn.execute(sa.text(
        "SELECT user_id, index_name, read_permission, write_permission, delete_permission FROM user_permissions"
    )).fetchall()
    
    # Group permissions by user_id
    user_permissions_dict = {}
    for user_id, index_name, read, write, delete in user_permissions:
        if user_id not in user_permissions_dict:
            user_permissions_dict[user_id] = {}
        
        user_permissions_dict[user_id][index_name] = {
            'read': bool(read),
            'write': bool(write),
            'delete': bool(delete)
        }
    
    # Update each user with its permissions
    for user_id, permissions in user_permissions_dict.items():
        conn.execute(
            sa.text("UPDATE users SET allowed_indexes = :permissions WHERE id = :user_id"),
            {"permissions": permissions, "user_id": user_id}
        )

    op.drop_table('user_permissions')
    op.drop_table('role_permissions')
    # ### end Alembic commands ###
